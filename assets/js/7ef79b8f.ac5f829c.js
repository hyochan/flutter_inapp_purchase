"use strict";(self.webpackChunkflutter_inapp_purchase_docs=self.webpackChunkflutter_inapp_purchase_docs||[]).push([[7113],{3762:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"api/methods/finish-transaction","title":"finishTransaction","description":"Completes a transaction and removes it from the queue.","source":"@site/docs/api/methods/finish-transaction.md","sourceDirName":"api/methods","slug":"/api/methods/finish-transaction","permalink":"/flutter_inapp_purchase/docs/api/methods/finish-transaction","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/flutter_inapp_purchase/tree/main/docs/docs/api/methods/finish-transaction.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"finishTransaction"}}');var a=i(4848),r=i(8453);const t={sidebar_position:6,title:"finishTransaction"},c="finishTransaction()",o={},d=[{value:"Overview",id:"overview",level:2},{value:"Signature",id:"signature",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Platform Behavior",id:"platform-behavior",level:2},{value:"iOS",id:"ios",level:3},{value:"Android",id:"android",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Transaction Completion",id:"basic-transaction-completion",level:3},{value:"With Purchase Stream",id:"with-purchase-stream",level:3},{value:"Complete Purchase Flow",id:"complete-purchase-flow",level:3},{value:"Android-Specific Handling",id:"android-specific-handling",level:2},{value:"Pending Transactions",id:"pending-transactions",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Transaction States",id:"transaction-states",level:2},{value:"Related Methods",id:"related-methods",level:2},{value:"Migration from v6.x",id:"migration-from-v6x",level:2},{value:"Important Notes",id:"important-notes",level:2}];function l(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"finishtransaction",children:"finishTransaction()"})}),"\n",(0,a.jsx)(e.p,{children:"Completes a transaction and removes it from the queue."}),"\n",(0,a.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"finishTransaction()"})," method marks a transaction as complete, removing it from the pending transactions queue. This is crucial for proper transaction management on both iOS and Android platforms."]}),"\n",(0,a.jsx)(e.h2,{id:"signature",children:"Signature"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-dart",children:"Future<void> finishTransaction({\n  required Purchase purchase,\n  bool? isConsumable,\n})\n"})}),"\n",(0,a.jsx)(e.h2,{id:"parameters",children:"Parameters"}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Parameter"}),(0,a.jsx)(e.th,{children:"Type"}),(0,a.jsx)(e.th,{children:"Required"}),(0,a.jsx)(e.th,{children:"Description"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"purchase"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Purchase"})}),(0,a.jsx)(e.td,{children:"\u2705"}),(0,a.jsx)(e.td,{children:"The purchase object to finish"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"isConsumable"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"bool?"})}),(0,a.jsx)(e.td,{children:"\u274c"}),(0,a.jsx)(e.td,{children:"Whether the product is consumable (affects Android behavior)"})]})]})]}),"\n",(0,a.jsx)(e.h2,{id:"platform-behavior",children:"Platform Behavior"}),"\n",(0,a.jsx)(e.h3,{id:"ios",children:"iOS"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Removes the transaction from StoreKit's payment queue"}),"\n",(0,a.jsx)(e.li,{children:"Required for all purchases (consumable and non-consumable)"}),"\n",(0,a.jsx)(e.li,{children:"Must be called after content delivery"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"android",children:"Android"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"For consumables: Consumes the purchase, allowing repurchase"}),"\n",(0,a.jsx)(e.li,{children:"For non-consumables: Acknowledges the purchase"}),"\n",(0,a.jsx)(e.li,{children:"Must acknowledge within 3 days or purchase is refunded"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,a.jsx)(e.h3,{id:"basic-transaction-completion",children:"Basic Transaction Completion"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-dart",children:"// Listen for purchases and finish them\nFlutterInappPurchase.purchaseUpdated.listen((Purchase? purchase) async {\n  if (purchase != null) {\n    // Verify and deliver content\n    await _verifyAndDeliver(purchase);\n\n    // Finish the transaction\n    await FlutterInappPurchase.instance.finishTransaction(\n      purchase: purchase,\n      isConsumable: _isConsumable(purchase.productId),\n    );\n  }\n});\n"})}),"\n",(0,a.jsx)(e.h3,{id:"with-purchase-stream",children:"With Purchase Stream"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-dart",children:"// Using the purchase stream\nFlutterInappPurchase.instance.purchaseUpdatedListener.listen((Purchase purchase) async {\n  // Process the purchase\n  await _processPurchase(purchase);\n\n  // Finish the transaction\n  await FlutterInappPurchase.instance.finishTransaction(\n    purchase: purchase,\n    isConsumable: true,\n  );\n});\n"})}),"\n",(0,a.jsx)(e.h3,{id:"complete-purchase-flow",children:"Complete Purchase Flow"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-dart",children:"class PurchaseHandler {\n  final _iap = FlutterInappPurchase.instance;\n  final _consumableIds = ['coins_100', 'coins_500', 'powerup_pack'];\n\n  void initialize() {\n    FlutterInappPurchase.purchaseUpdated.listen(_handlePurchase);\n  }\n\n  Future<void> _handlePurchase(Purchase? purchase) async {\n    if (purchase == null) return;\n\n    try {\n      // Step 1: Verify the purchase\n      final isValid = await _verifyPurchase(purchase);\n      if (!isValid) {\n        print('Invalid purchase detected');\n        return;\n      }\n\n      // Step 2: Deliver the content\n      await _deliverContent(purchase.productId!);\n\n      // Step 3: Finish the transaction\n      final isConsumable = _consumableIds.contains(purchase.productId);\n      await _iap.finishTransaction(\n        purchase: purchase,\n        isConsumable: isConsumable,\n      );\n\n      print('Transaction completed successfully');\n\n    } catch (e) {\n      print('Error processing purchase: $e');\n      // Don't finish transaction if processing failed\n      // This keeps it in the queue for retry\n    }\n  }\n\n  Future<bool> _verifyPurchase(Purchase item) async {\n    // Implement your verification logic\n    // - Verify receipt with your backend\n    // - Check transaction ID uniqueness\n    // - Validate product ID\n    return true;\n  }\n\n  Future<void> _deliverContent(String productId) async {\n    // Deliver the purchased content\n    switch (productId) {\n      case 'coins_100':\n        await _addCoins(100);\n        break;\n      case 'coins_500':\n        await _addCoins(500);\n        break;\n      case 'premium':\n        await _unlockPremium();\n        break;\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"android-specific-handling",children:"Android-Specific Handling"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-dart",children:"Future<void> handleAndroidPurchase(Purchase item) async {\n  if (!Platform.isAndroid) return;\n\n  // Check acknowledgment status\n  if (item.isAcknowledgedAndroid == false) {\n    if (_isConsumable(item.productId)) {\n      // Consume the purchase\n      await _iap.consumePurchaseAndroid(item.purchaseToken!);\n    } else {\n      // Acknowledge non-consumable\n      await _iap.acknowledgePurchaseAndroid(\n        purchaseToken: item.purchaseToken!,\n      );\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"pending-transactions",children:"Pending Transactions"}),"\n",(0,a.jsx)(e.p,{children:"Handle pending transactions on app startup:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-dart",children:"class TransactionManager {\n  Future<void> processPendingTransactions() async {\n    try {\n      // Get pending transactions\n      final pending = await FlutterInappPurchase.instance.getPendingTransactionsIOS();\n\n      if (pending != null && pending.isNotEmpty) {\n        print('Found ${pending.length} pending transactions');\n\n        for (var transaction in pending) {\n          // Process each pending transaction\n          await _processPendingTransaction(transaction);\n        }\n      }\n    } catch (e) {\n      print('Error processing pending transactions: $e');\n    }\n  }\n\n  Future<void> _processPendingTransaction(Purchase item) async {\n    // Verify the transaction\n    final isValid = await _verifyTransaction(item);\n\n    if (isValid) {\n      // Deliver content if not already delivered\n      if (!await _isContentDelivered(item.transactionId)) {\n        await _deliverContent(item.productId!);\n      }\n\n      // Finish the transaction\n      await FlutterInappPurchase.instance.finishTransaction(\n        purchase: item,\n      );\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Always Verify First"}),": Verify purchases before finishing transactions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Handle Failures"}),": Keep transactions pending if verification fails"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Idempotent Delivery"}),": Ensure content delivery is idempotent"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Process on Startup"}),": Check for pending transactions when app launches"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Track Delivery"}),": Maintain records of delivered content"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-dart",children:"Future<void> safeFinishTransaction(Purchase item) async {\n  const maxRetries = 3;\n  var retryCount = 0;\n\n  while (retryCount < maxRetries) {\n    try {\n      await _iap.finishTransaction(\n        purchase: item,\n        isConsumable: _isConsumable(item.productId),\n      );\n      print('Transaction finished successfully');\n      break;\n\n    } catch (e) {\n      retryCount++;\n      print('Failed to finish transaction (attempt $retryCount): $e');\n\n      if (retryCount >= maxRetries) {\n        // Log error but don't throw\n        // Transaction will remain pending\n        _logError('Failed to finish transaction after $maxRetries attempts', item);\n      } else {\n        // Wait before retry\n        await Future.delayed(Duration(seconds: retryCount));\n      }\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"transaction-states",children:"Transaction States"}),"\n",(0,a.jsx)(e.p,{children:"Monitor transaction states for proper handling:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-dart",children:"void handleTransactionState(Purchase item) {\n  if (Platform.isIOS) {\n    switch (item.transactionStateIOS) {\n      case TransactionState.purchased:\n      case TransactionState.restored:\n        // Safe to finish\n        _finishTransaction(item);\n        break;\n      case TransactionState.failed:\n        // Don't finish failed transactions\n        print('Transaction failed');\n        break;\n      case TransactionState.purchasing:\n      case TransactionState.deferred:\n        // Wait for final state\n        print('Transaction pending');\n        break;\n    }\n  } else if (Platform.isAndroid) {\n    switch (item.purchaseStateAndroid) {\n      case PurchaseState.purchased:\n        // Safe to finish\n        _finishTransaction(item);\n        break;\n      case PurchaseState.pending:\n        // Don't finish pending transactions\n        print('Purchase pending');\n        break;\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"related-methods",children:"Related Methods"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/flutter_inapp_purchase/docs/api/methods/request-purchase",children:(0,a.jsx)(e.code,{children:"requestPurchase()"})})," - Initiates a purchase"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/flutter_inapp_purchase/docs/api/methods/get-available-purchases",children:(0,a.jsx)(e.code,{children:"getAvailablePurchases()"})})," - Gets unfinished purchases"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"acknowledgePurchaseAndroid()"})," - Android-specific acknowledgment (see example above)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"consumePurchaseAndroid()"})," - Android-specific consumption (see example above)"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"migration-from-v6x",children:"Migration from v6.x"}),"\n",(0,a.jsxs)(e.p,{children:["Version 7.0 significantly simplifies the ",(0,a.jsx)(e.code,{children:"finishTransaction"})," API:"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-dart",children:"// Before (v6.x) - 10 individual parameters\nawait iap.finishTransaction(\n  id: purchase.id,\n  isAutoRenewing: purchase.isAutoRenewing,\n  platform: purchase.platform,\n  productId: purchase.productId,\n  purchaseState: purchase.purchaseState,\n  purchaseToken: purchase.purchaseToken,\n  quantity: purchase.quantity,\n  transactionDate: purchase.transactionDate,\n  isConsumable: true,\n);\n\n// After (v7.0) - Just pass the Purchase object\nawait iap.finishTransaction(\n  purchase: purchase,\n  isConsumable: true,\n);\n"})}),"\n",(0,a.jsxs)(e.p,{children:["This reduces boilerplate by ",(0,a.jsx)(e.strong,{children:"80%"})," while maintaining all functionality. The method now handles serialization internally."]}),"\n",(0,a.jsx)(e.h2,{id:"important-notes",children:"Important Notes"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"iOS Requirements"}),": All transactions must be finished, even failed ones"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Android 3-Day Rule"}),": Acknowledge purchases within 3 days or they're refunded"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Consumables"}),": Must be consumed on Android to allow repurchase"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Network Failures"}),": Transactions remain pending if finish fails"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"App Termination"}),": Unfinished transactions persist across app sessions"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(l,{...n})}):l(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>c});var s=i(6540);const a={},r=s.createContext(a);function t(n){const e=s.useContext(r);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:t(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);