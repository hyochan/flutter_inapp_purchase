"use strict";(self.webpackChunkflutter_inapp_purchase_docs=self.webpackChunkflutter_inapp_purchase_docs||[]).push([[7482],{26730:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>d,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"guides/subscription-validation","title":"Subscription Validation","description":"flutterinapppurchase exposes modern StoreKit 2 (iOS) and Google Play Billing (Android) pipelines. This guide walks through the data available on the Dart side, how it maps to the underlying native APIs, and practical strategies to answer common lifecycle questions such as \\"is the user currently inside their free trial?\\"","source":"@site/docs/guides/subscription-validation.md","sourceDirName":"guides","slug":"/guides/subscription-validation","permalink":"/flutter_inapp_purchase/guides/subscription-validation","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/flutter_inapp_purchase/tree/main/docs/docs/guides/subscription-validation.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Subscription Validation"},"sidebar":"docsSidebar","previous":{"title":"Subscription Offers","permalink":"/flutter_inapp_purchase/guides/subscription-offers"},"next":{"title":"Offer Code Redemption","permalink":"/flutter_inapp_purchase/guides/offer-code-redemption"}}');var t=n(74848),r=n(28453),a=n(35159),c=n(71437);const d={sidebar_position:4,title:"Subscription Validation"},o="Subscription Validation",l={},h=[{value:"Summary of Key APIs",id:"summary-of-key-apis",level:2},{value:"Working with getAvailablePurchases",id:"working-with-getavailablepurchases",level:2},{value:"Data Included",id:"data-included",level:3},{value:"Limitations",id:"limitations",level:3},{value:"Using getActiveSubscriptions",id:"using-getactivesubscriptions",level:2},{value:"Fields Available",id:"fields-available",level:3},{value:"Deriving Subscription Phase",id:"deriving-subscription-phase",level:2},{value:"StoreKit 2 Status API (iOS)",id:"storekit-2-status-api-ios",level:2},{value:"Phase Reference",id:"phase-reference",level:3},{value:"Server-Side Validation",id:"server-side-validation",level:2},{value:"iOS - App Store Server API",id:"ios---app-store-server-api",level:3},{value:"Android - Google Play Developer API",id:"android---google-play-developer-api",level:3},{value:"Client-Side Validation (iOS)",id:"client-side-validation-ios",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Complete Flow Example",id:"complete-flow-example",level:2},{value:"Subscription Renewal Detection",id:"subscription-renewal-detection",level:2},{value:"Platform Differences",id:"platform-differences",level:3},{value:"Why This Matters",id:"why-this-matters",level:3},{value:"Recommended Solution: IAPKit Verification",id:"recommended-solution-iapkit-verification",level:3},{value:"IAPKit Purchase States",id:"iapkit-purchase-states",level:3},{value:"Custom Hook Example",id:"custom-hook-example",level:3},{value:"When to Check Subscription Status",id:"when-to-check-subscription-status",level:3},{value:"Next Steps",id:"next-steps",level:2}];function p(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"subscription-validation",children:"Subscription Validation"})}),"\n",(0,t.jsx)(a.A,{}),"\n",(0,t.jsx)(i.p,{children:'flutter_inapp_purchase exposes modern StoreKit 2 (iOS) and Google Play Billing (Android) pipelines. This guide walks through the data available on the Dart side, how it maps to the underlying native APIs, and practical strategies to answer common lifecycle questions such as "is the user currently inside their free trial?"'}),"\n",(0,t.jsxs)(i.p,{children:["iOS and Android share the same high-level API surface, but individual capabilities differ. Notes in each section call out platform-specific behaviour\u2014for example, ",(0,t.jsx)(i.code,{children:"subscriptionStatusIOS"})," only exists on Apple platforms, whereas Android relies on Purchase objects and the Play Developer API."]}),"\n",(0,t.jsx)(i.h2,{id:"summary-of-key-apis",children:"Summary of Key APIs"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Capability"}),(0,t.jsx)(i.th,{children:"API"}),(0,t.jsx)(i.th,{children:"iOS"}),(0,t.jsx)(i.th,{children:"Android"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Fetch latest entitlement records the store still considers active"}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"getAvailablePurchases"})}),(0,t.jsx)(i.td,{children:"Wraps StoreKit 2 Transaction.currentEntitlements; optional flags control listener mirror & active-only filtering"}),(0,t.jsx)(i.td,{children:"Queries Play Billing twice (inapp + subs) and merges validated purchases, exposing purchaseToken for server use"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Filter entitlements down to subscriptions only"}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"getActiveSubscriptions"})}),(0,t.jsx)(i.td,{children:"Adds expirationDateIOS, daysUntilExpirationIOS, environmentIOS convenience fields"}),(0,t.jsx)(i.td,{children:"Re-shapes merged purchase list and surfaces autoRenewingAndroid, purchaseToken, and willExpireSoon placeholders"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Inspect fine-grained subscription phase"}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"subscriptionStatusIOS"})}),(0,t.jsx)(i.td,{children:"StoreKit 2 status API (inTrialPeriod, inGracePeriod, etc.)"}),(0,t.jsx)(i.td,{children:"Not available; pair getAvailablePurchases with Play Developer API for phase data"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Retrieve receipts for validation"}),(0,t.jsxs)(i.td,{children:[(0,t.jsx)(i.code,{children:"getReceiptDataIOS"}),", ",(0,t.jsx)(i.code,{children:"validateReceiptIOS"})]}),(0,t.jsx)(i.td,{children:"Provides App Store receipt / JWS for backend validation"}),(0,t.jsx)(i.td,{children:"validateReceipt forwards to OpenIAP's Google Play validator and expects purchaseToken / packageName"})]})]})]}),"\n",(0,t.jsx)(i.h2,{id:"working-with-getavailablepurchases",children:"Working with getAvailablePurchases"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"getAvailablePurchases"})," returns every purchase that the native store still considers active for the signed-in user."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"iOS"})," \u2014 The library bridges directly to StoreKit 2's Transaction.currentEntitlements, so each item is a fully validated ",(0,t.jsx)(i.code,{children:"PurchaseIOS"}),". Optional flags (",(0,t.jsx)(i.code,{children:"onlyIncludeActiveItemsIOS"}),", ",(0,t.jsx)(i.code,{children:"alsoPublishToEventListenerIOS"}),") are forwarded to StoreKit and mimic the native behaviour."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Android"})," \u2014 Google Play Billing keeps one list for in-app products and another for subscriptions. The wrapper automatically queries both (",(0,t.jsx)(i.code,{children:"type: 'inapp'"})," and ",(0,t.jsx)(i.code,{children:"type: 'subs'"}),"), merges the results, and validates them before returning control to Dart."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"class SubscriptionGate extends StatefulWidget {\n  final List<String> subscriptionIds;\n\n  const SubscriptionGate({required this.subscriptionIds, Key? key}) : super(key: key);\n\n  @override\n  State<SubscriptionGate> createState() => _SubscriptionGateState();\n}\n\nclass _SubscriptionGateState extends State<SubscriptionGate> {\n  final _iap = FlutterInappPurchase.instance;\n  Map<String, ActiveSubscription> _activeSubscriptionInfo = {};\n  bool _hasActiveSubscription = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _checkActiveSubscriptions();\n  }\n\n  Future<void> _checkActiveSubscriptions() async {\n    try {\n      // Get active subscription summaries\n      final summaries = await _iap.getActiveSubscriptions(widget.subscriptionIds);\n\n      // Get corresponding Purchase objects for additional details\n      final purchases = await _iap.getAvailablePurchases(\n        onlyIncludeActiveItemsIOS: true,\n      );\n\n      // Create map of summaries by product ID\n      final summaryByProduct = <String, ActiveSubscription>{};\n      for (final summary in summaries) {\n        summaryByProduct[summary.productId] = summary;\n      }\n\n      // Match purchases with summaries\n      final activeSubs = <Purchase>[];\n      final addedProducts = <String>{};\n\n      for (final purchase in purchases) {\n        if (summaryByProduct.containsKey(purchase.productId) &&\n            addedProducts.add(purchase.productId)) {\n          activeSubs.add(purchase);\n        }\n      }\n\n      if (!mounted) return;\n\n      setState(() {\n        _activeSubscriptionInfo = summaryByProduct;\n        _hasActiveSubscription = activeSubs.isNotEmpty;\n      });\n    } catch (e) {\n      debugPrint('Error checking subscriptions: $e');\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Render locked/unlocked UI based on subscription status\n    return _hasActiveSubscription ? UnlockedContent() : LockedContent();\n  }\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"data-included",children:"Data Included"}),"\n",(0,t.jsx)(i.p,{children:"For each purchase you can inspect fields such as:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"transactionDate"}),": Transaction timestamp"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"transactionId"}),": Unique transaction identifier"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"productId"}),": Product SKU"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"purchaseToken"}),": Token for server-side validation"]}),"\n",(0,t.jsx)(i.li,{children:"Platform-specific fields (see Purchase types)"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsx)(i.p,{children:'StoreKit does not bake "current phase" indicators into these records. To answer questions like "is the user still in a free trial?" you need either the StoreKit status API or server-side receipt validation.'}),"\n",(0,t.jsx)(i.h2,{id:"using-getactivesubscriptions",children:"Using getActiveSubscriptions"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"getActiveSubscriptions"})," is a helper that filters down to subscription products and adds convenience fields. It returns an array of ",(0,t.jsx)(i.code,{children:"ActiveSubscription"})," objects:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"final activeSubscriptions = await iap.getActiveSubscriptions([\n  'yearly_subscription',\n  'monthly_subscription',\n]);\n\nif (activeSubscriptions.isEmpty) {\n  // User has no valid subscription\n  print('No active subscriptions');\n} else {\n  for (final sub in activeSubscriptions) {\n    print('Product: ${sub.productId}');\n    print('Transaction ID: ${sub.transactionId}');\n    print('Expiration (iOS): ${sub.expirationDateIOS}');\n    print('Auto-renewing (Android): ${sub.autoRenewingAndroid}');\n    print('Environment (iOS): ${sub.environmentIOS}');\n  }\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"fields-available",children:"Fields Available"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"isActive"}),": Always true as long as the subscription remains in the current entitlement set"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"expirationDateIOS"})," & ",(0,t.jsx)(i.code,{children:"daysUntilExpirationIOS"}),": Surfaced directly from StoreKit"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"transactionId"})," / ",(0,t.jsx)(i.code,{children:"purchaseToken"}),": Handy for reconciling with receipts or Play Billing"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"willExpireSoon"}),": Flag set when the subscription is within its grace window"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"autoRenewingAndroid"}),": Reflects the Google Play auto-renew status"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"environmentIOS"}),": Sandbox or Production"]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Platform note"}),": On iOS the helper re-shapes StoreKit 2 entitlement objects. On Android it operates on the merged inapp + subs purchase list, so the output contains both one-time products and subscriptions unless you filter by specific product IDs."]}),"\n",(0,t.jsx)(i.h2,{id:"deriving-subscription-phase",children:"Deriving Subscription Phase"}),"\n",(0,t.jsx)(i.p,{children:"If you want a coarse subscription phase that works on both platforms, compute it from the data:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"enum SubscriptionPhase { subscribed, expiringSoon, expired }\n\nconst msInDay = 1000 * 60 * 60 * 24;\nconst graceWindowDays = 3;\n\nFuture<SubscriptionPhase> getCurrentPhase(String sku) async {\n  final subscriptions = await iap.getActiveSubscriptions([sku]);\n  final entry = subscriptions.where((sub) => sub.productId == sku).firstOrNull;\n\n  if (entry == null) {\n    return SubscriptionPhase.expired;\n  }\n\n  final now = DateTime.now().millisecondsSinceEpoch;\n  final expiresAt = entry.expirationDateIOS;\n\n  if (entry.daysUntilExpirationIOS != null && entry.daysUntilExpirationIOS! <= 0) {\n    return SubscriptionPhase.expired;\n  }\n\n  if (expiresAt != null && expiresAt <= now) {\n    return SubscriptionPhase.expired;\n  }\n\n  final graceWindowMs = graceWindowDays * msInDay;\n  if ((expiresAt != null && expiresAt - now <= graceWindowMs) ||\n      (entry.daysUntilExpirationIOS != null &&\n          entry.daysUntilExpirationIOS! * msInDay <= graceWindowMs) ||\n      entry.autoRenewingAndroid == false) {\n    return SubscriptionPhase.expiringSoon;\n  }\n\n  return SubscriptionPhase.subscribed;\n}\n"})}),"\n",(0,t.jsx)(i.h2,{id:"storekit-2-status-api-ios",children:"StoreKit 2 Status API (iOS)"}),"\n",(0,t.jsxs)(i.p,{children:["When you need to know the exact lifecycle phase on iOS, call ",(0,t.jsx)(i.code,{children:"subscriptionStatusIOS"}),". This maps to StoreKit 2's ",(0,t.jsx)(i.code,{children:"Product.SubscriptionInfo.Status"})," API and returns an array of status entries for the subscription group."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"final statuses = await iap.subscriptionStatusIOS('yearly_subscription');\nfinal latestState = statuses.isNotEmpty ? statuses.first.state : 'unknown';\n\nswitch (latestState) {\n  case 'subscribed':\n    print('Subscription is active');\n    break;\n  case 'inTrialPeriod':\n    print('User is in free trial');\n    break;\n  case 'inGracePeriod':\n    print('Auto-renewal failed, in grace period');\n    break;\n  case 'expired':\n    print('Subscription expired');\n    break;\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"phase-reference",children:"Phase Reference"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"State Value"}),(0,t.jsx)(i.th,{children:"Meaning"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"subscribed"})}),(0,t.jsx)(i.td,{children:"Subscription is active and billing is up to date"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"expired"})}),(0,t.jsx)(i.td,{children:"Subscription is no longer active"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"inGracePeriod"})}),(0,t.jsx)(i.td,{children:"Auto-renewal failed but StoreKit granted a grace period"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"inBillingRetryPeriod"})}),(0,t.jsx)(i.td,{children:"Auto-renewal failed and StoreKit is retrying payment"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"revoked"})}),(0,t.jsx)(i.td,{children:"Apple revoked the subscription (e.g., refunds)"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"inIntroOfferPeriod"})}),(0,t.jsx)(i.td,{children:"User is in a paid introductory offer"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"inTrialPeriod"})}),(0,t.jsx)(i.td,{children:"User is currently in the free-trial window"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"paused"})}),(0,t.jsx)(i.td,{children:"Subscription manually paused by the user"})]})]})]}),"\n",(0,t.jsx)(i.h2,{id:"server-side-validation",children:"Server-Side Validation"}),"\n",(0,t.jsx)(i.h3,{id:"ios---app-store-server-api",children:"iOS - App Store Server API"}),"\n",(0,t.jsx)(i.p,{children:"Validate receipts on your backend:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"// Get receipt data\nfinal receiptData = await iap.getReceiptDataIOS();\n\n// Send to your backend for validation\nfinal response = await http.post(\n  Uri.parse('https://your-backend.com/validate-ios'),\n  body: {'receipt_data': receiptData},\n);\n"})}),"\n",(0,t.jsx)(i.p,{children:"Backend validation (App Store verifyReceipt endpoint):"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-javascript",children:"const response = await fetch(\n  'https://buy.itunes.apple.com/verifyReceipt',\n  {\n    method: 'POST',\n    body: JSON.stringify({\n      'receipt-data': receiptData,\n      'password': SHARED_SECRET,\n    }),\n  }\n);\n\nconst data = await response.json();\n// Check data.status === 0 for valid receipt\n// Inspect data.latest_receipt_info for is_trial_period, etc.\n"})}),"\n",(0,t.jsx)(i.h3,{id:"android---google-play-developer-api",children:"Android - Google Play Developer API"}),"\n",(0,t.jsx)(i.p,{children:"Validate purchase tokens on your backend using Google Play Developer API to get detailed subscription phase data."}),"\n",(0,t.jsx)(i.h2,{id:"client-side-validation-ios",children:"Client-Side Validation (iOS)"}),"\n",(0,t.jsx)(i.p,{children:"For quick client-side validation on iOS:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"final result = await iap.validateReceiptIOS(\n  sku: 'yearly_subscription',\n);\n\nif (result.isValid) {\n  print('Receipt is valid');\n  print('JWS Representation: ${result.jwsRepresentation}');\n} else {\n  print('Receipt validation failed');\n}\n"})}),"\n",(0,t.jsx)(i.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:["Use ",(0,t.jsx)(i.code,{children:"subscriptionStatusIOS"})," for fast, on-device checks"]})," when UI needs to react immediately (iOS only)"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Periodically upload receipts to your backend"})," for authoritative validation and entitlement provisioning"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Recalculate client caches"})," (",(0,t.jsx)(i.code,{children:"getAvailablePurchases"}),") after server reconciliation"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Combine both approaches"}),": Use client APIs for immediate feedback, server validation for security"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Handle both platforms"}),": Use ",(0,t.jsx)(i.code,{children:"getActiveSubscriptions"})," for cross-platform checks, enhance with ",(0,t.jsx)(i.code,{children:"subscriptionStatusIOS"})," on iOS"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"complete-flow-example",children:"Complete Flow Example"}),"\n",(0,t.jsx)(i.p,{children:"A typical subscription screen might:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["Call ",(0,t.jsx)(i.code,{children:"initConnection"})," and ",(0,t.jsx)(i.code,{children:"fetchProducts"})," when mounted"]}),"\n",(0,t.jsx)(i.li,{children:"Set up purchase listeners to observe updates"}),"\n",(0,t.jsxs)(i.li,{children:["Fetch ",(0,t.jsx)(i.code,{children:"getAvailablePurchases"})," on launch to restore entitlements"]}),"\n",(0,t.jsxs)(i.li,{children:["Query ",(0,t.jsx)(i.code,{children:"subscriptionStatusIOS"})," (iOS) to display trial/grace period status"]}),"\n",(0,t.jsx)(i.li,{children:"Sync receipts to your server to unlock cross-device access"}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"class SubscriptionManager {\n  final _iap = FlutterInappPurchase.instance;\n\n  Future<void> initialize() async {\n    await _iap.initConnection();\n\n    // Restore purchases\n    final purchases = await _iap.getAvailablePurchases();\n\n    // Check subscription status (iOS)\n    if (Platform.isIOS) {\n      final statuses = await _iap.subscriptionStatusIOS('yearly_sub');\n      final inTrial = statuses.any((s) => s.state == 'inTrialPeriod');\n      print('In trial: $inTrial');\n    }\n\n    // Validate on server\n    if (Platform.isIOS) {\n      final receiptData = await _iap.getReceiptDataIOS();\n      await validateOnServer(receiptData);\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(i.h2,{id:"subscription-renewal-detection",children:"Subscription Renewal Detection"}),"\n",(0,t.jsx)(i.p,{children:"iOS and Android handle subscription renewals differently, which affects how your app detects renewed subscriptions when the user opens the app."}),"\n",(0,t.jsx)(i.h3,{id:"platform-differences",children:"Platform Differences"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Platform"}),(0,t.jsx)(i.th,{children:"Behavior"}),(0,t.jsx)(i.th,{children:"Renewal Detection"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.strong,{children:"iOS (StoreKit 2)"})}),(0,t.jsx)(i.td,{children:"Renewed subscriptions are automatically detected when the app launches"}),(0,t.jsxs)(i.td,{children:[(0,t.jsx)(i.code,{children:"purchaseUpdatedListener"})," fires for renewals; ",(0,t.jsx)(i.code,{children:"getAvailablePurchases()"})," returns current entitlements"]})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.strong,{children:"Android (Google Play Billing)"})}),(0,t.jsxs)(i.td,{children:[(0,t.jsx)(i.code,{children:"purchaseUpdatedListener"})," does NOT fire for renewals that occurred while the app was closed"]}),(0,t.jsxs)(i.td,{children:["Must call ",(0,t.jsx)(i.code,{children:"getAvailablePurchases()"})," and verify with server to detect renewals"]})]})]})]}),"\n",(0,t.jsx)(i.h3,{id:"why-this-matters",children:"Why This Matters"}),"\n",(0,t.jsxs)(i.p,{children:["On Android, if a subscription renews while your app is closed (or the device is off), the ",(0,t.jsx)(i.code,{children:"purchaseUpdatedListener"})," will not emit an event for that renewal when the app reopens. This means relying solely on the listener can result in users losing access to premium features until they make a new purchase."]}),"\n",(0,t.jsx)(i.h3,{id:"recommended-solution-iapkit-verification",children:"Recommended Solution: IAPKit Verification"}),"\n",(0,t.jsxs)(i.p,{children:["Use ",(0,t.jsx)(c.A,{children:"IAPKit"})," to get authoritative subscription status on app launch:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"Future<void> checkSubscriptionStatusOnLaunch() async {\n  final iap = FlutterInappPurchase.instance;\n\n  // Get available purchases from the device\n  final purchases = await iap.getAvailablePurchases();\n\n  for (final purchase in purchases) {\n    // Verify each purchase with IAPKit for authoritative status\n    final result = await iap.verifyPurchaseWithProvider(\n      VerifyPurchaseWithProviderProps(\n        provider: VerifyPurchaseProvider.iapkit,\n        iapkit: RequestVerifyPurchaseWithIapkitProps(\n          apiKey: 'your-iapkit-api-key',\n          apple: RequestVerifyPurchaseWithIapkitAppleProps(\n            jws: purchase.purchaseToken,\n          ),\n          google: RequestVerifyPurchaseWithIapkitGoogleProps(\n            purchaseToken: purchase.purchaseToken,\n          ),\n        ),\n      ),\n    );\n\n    if (result.iapkit case final iapkit?) {\n      switch (iapkit.state) {\n        case IapkitPurchaseState.Entitled:\n          // User has active subscription - grant access\n          await grantPremiumAccess(purchase.productId);\n        case IapkitPurchaseState.Expired:\n          // Subscription expired - revoke access\n          await revokePremiumAccess(purchase.productId);\n        case IapkitPurchaseState.Canceled:\n          // User canceled but may still have time remaining\n          // Check expirationDate if available\n        default:\n          debugPrint('Purchase state: ${iapkit.state}');\n      }\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"iapkit-purchase-states",children:"IAPKit Purchase States"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"State"}),(0,t.jsx)(i.th,{children:"Description"}),(0,t.jsx)(i.th,{children:"Action"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"entitled"})}),(0,t.jsx)(i.td,{children:"User has active entitlement"}),(0,t.jsx)(i.td,{children:"Grant premium access"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"expired"})}),(0,t.jsx)(i.td,{children:"Subscription has expired"}),(0,t.jsx)(i.td,{children:"Revoke premium access"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"canceled"})}),(0,t.jsx)(i.td,{children:"User canceled, may have time remaining"}),(0,t.jsx)(i.td,{children:"Check expiration, show renewal prompt"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"pending"})}),(0,t.jsx)(i.td,{children:"Purchase pending (e.g., parental approval)"}),(0,t.jsx)(i.td,{children:"Show pending state UI"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"pending-acknowledgment"})}),(0,t.jsx)(i.td,{children:"Purchase needs acknowledgment (Android)"}),(0,t.jsxs)(i.td,{children:["Call ",(0,t.jsx)(i.code,{children:"finishTransaction()"})]})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"inauthentic"})}),(0,t.jsx)(i.td,{children:"Purchase failed validation"}),(0,t.jsx)(i.td,{children:"Do not grant access, investigate"})]})]})]}),"\n",(0,t.jsx)(i.h3,{id:"custom-hook-example",children:"Custom Hook Example"}),"\n",(0,t.jsx)(i.p,{children:"Create a reusable hook to manage subscription status:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"class SubscriptionStatusManager {\n  final _iap = FlutterInappPurchase.instance;\n  final String _apiKey;\n\n  bool _isSubscribed = false;\n  IapkitPurchaseState? _subscriptionState;\n\n  SubscriptionStatusManager({required String apiKey}) : _apiKey = apiKey;\n\n  bool get isSubscribed => _isSubscribed;\n  IapkitPurchaseState? get subscriptionState => _subscriptionState;\n\n  Future<void> refreshSubscriptionStatus(List<String> subscriptionIds) async {\n    try {\n      final purchases = await _iap.getAvailablePurchases();\n\n      // Filter to subscription products only\n      final subscriptionPurchases = purchases.where(\n        (p) => subscriptionIds.contains(p.productId),\n      );\n\n      if (subscriptionPurchases.isEmpty) {\n        _isSubscribed = false;\n        _subscriptionState = null;\n        return;\n      }\n\n      // Verify the most recent subscription purchase\n      final purchase = subscriptionPurchases.first;\n      final result = await _iap.verifyPurchaseWithProvider(\n        VerifyPurchaseWithProviderProps(\n          provider: VerifyPurchaseProvider.iapkit,\n          iapkit: RequestVerifyPurchaseWithIapkitProps(\n            apiKey: _apiKey,\n            apple: RequestVerifyPurchaseWithIapkitAppleProps(\n              jws: purchase.purchaseToken,\n            ),\n            google: RequestVerifyPurchaseWithIapkitGoogleProps(\n              purchaseToken: purchase.purchaseToken,\n            ),\n          ),\n        ),\n      );\n\n      if (result.iapkit case final iapkit?) {\n        _subscriptionState = iapkit.state;\n        _isSubscribed = iapkit.isValid;\n      }\n    } catch (e) {\n      debugPrint('Failed to refresh subscription status: $e');\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"when-to-check-subscription-status",children:"When to Check Subscription Status"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"App Launch"})," - Always check on ",(0,t.jsx)(i.code,{children:"initState"})," or app resume"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"After Purchase"})," - Verify immediately after ",(0,t.jsx)(i.code,{children:"purchaseUpdatedListener"})," fires"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Periodically"})," - For long-running sessions, check every few hours"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"On Demand"})," - When user accesses premium features"]}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"class PremiumScreen extends StatefulWidget {\n  @override\n  State<PremiumScreen> createState() => _PremiumScreenState();\n}\n\nclass _PremiumScreenState extends State<PremiumScreen> with WidgetsBindingObserver {\n  final _subscriptionManager = SubscriptionStatusManager(\n    apiKey: 'your-iapkit-api-key',\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addObserver(this);\n    _checkSubscription();\n  }\n\n  @override\n  void didChangeAppLifecycleState(AppLifecycleState state) {\n    if (state == AppLifecycleState.resumed) {\n      // Check subscription when app comes to foreground\n      _checkSubscription();\n    }\n  }\n\n  Future<void> _checkSubscription() async {\n    await _subscriptionManager.refreshSubscriptionStatus([\n      'monthly_subscription',\n      'yearly_subscription',\n    ]);\n    setState(() {});\n  }\n\n  @override\n  void dispose() {\n    WidgetsBinding.instance.removeObserver(this);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return _subscriptionManager.isSubscribed\n        ? PremiumContent()\n        : SubscriptionPaywall();\n  }\n}\n"})}),"\n",(0,t.jsx)(i.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"./subscription-offers",children:"Subscription Offers"})," - Handle subscription purchases"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"./error-handling",children:"Error Handling"})," - Handle validation errors"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"./troubleshooting",children:"Troubleshooting"})," - Debug validation issues"]}),"\n"]})]})}function u(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},27856:(e,i,n)=>{n.d(i,{I:()=>t,V:()=>s});const s="https://iapkit.com",t="https://www.hyo.dev/api/ad-banner/cmjf0l1x30001249hbi91aop6"},28453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>c});var s=n(96540);const t={},r=s.createContext(t);function a(e){const i=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:i},e.children)}},35159:(e,i,n)=>{n.d(i,{A:()=>r});n(96540);var s=n(27856),t=n(74848);function r({style:e}){return(0,t.jsx)("div",{style:{marginTop:24,marginBottom:24,textAlign:"center",...e},children:(0,t.jsx)("a",{href:s.V,target:"_blank",rel:"noopener noreferrer",onClick:async()=>{try{await fetch(s.I,{method:"POST",mode:"no-cors"})}catch(e){}},children:(0,t.jsx)("img",{src:n(65860).A,alt:"IapKit - Fraud-proof your in-app purchases",style:{objectFit:"cover",border:"none"}})})})}},65860:(e,i,n)=>{n.d(i,{A:()=>s});const s=n.p+"assets/images/iapkit-banner-c71d8c3f875ca90b812e7b54822795d2.gif"},71437:(e,i,n)=>{n.d(i,{A:()=>r});n(96540);var s=n(27856),t=n(74848);function r({children:e,path:i=""}){return(0,t.jsx)("a",{href:`${s.V}${i}`,target:"_blank",rel:"noopener noreferrer",onClick:async()=>{try{await fetch(s.I,{method:"POST",mode:"no-cors"})}catch(e){}},children:e})}}}]);