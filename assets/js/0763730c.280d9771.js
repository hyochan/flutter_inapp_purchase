"use strict";(self.webpackChunkflutter_inapp_purchase_docs=self.webpackChunkflutter_inapp_purchase_docs||[]).push([[2604],{27856:(n,e,i)=>{i.d(e,{I:()=>s,V:()=>a});const a="https://iapkit.com",s="https://www.hyo.dev/api/ad-banner/cmjf0l1x30001249hbi91aop6"},28453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>c});var a=i(96540);const s={},r=a.createContext(s);function t(n){const e=a.useContext(r);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:t(n.components),a.createElement(r.Provider,{value:e},n.children)}},35159:(n,e,i)=>{i.d(e,{A:()=>r});i(96540);var a=i(27856),s=i(74848);function r({style:n}){return(0,s.jsx)("div",{style:{marginTop:24,marginBottom:24,textAlign:"center",...n},children:(0,s.jsx)("a",{href:a.V,target:"_blank",rel:"noopener noreferrer",onClick:async()=>{try{await fetch(a.I,{method:"POST",mode:"no-cors"})}catch(n){}},children:(0,s.jsx)("img",{src:i(65860).A,alt:"IapKit - Fraud-proof your in-app purchases",style:{objectFit:"cover",border:"none"}})})})}},65860:(n,e,i)=>{i.d(e,{A:()=>a});const a=i.p+"assets/images/iapkit-banner-c71d8c3f875ca90b812e7b54822795d2.gif"},97571:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>c,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"api/methods/finish-transaction","title":"finishTransaction","description":"Completes a transaction and removes it from the queue.","source":"@site/versioned_docs/version-8.1/api/methods/finish-transaction.md","sourceDirName":"api/methods","slug":"/api/methods/finish-transaction","permalink":"/flutter_inapp_purchase/8.1/api/methods/finish-transaction","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/flutter_inapp_purchase/tree/main/docs/versioned_docs/version-8.1/api/methods/finish-transaction.md","tags":[],"version":"8.1","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"finishTransaction"}}');var s=i(74848),r=i(28453),t=i(35159);const c={sidebar_position:6,title:"finishTransaction"},o="finishTransaction()",d={},l=[{value:"Overview",id:"overview",level:2},{value:"Signature",id:"signature",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Platform Behavior",id:"platform-behavior",level:2},{value:"iOS",id:"ios",level:3},{value:"Android",id:"android",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Transaction Completion",id:"basic-transaction-completion",level:3},{value:"With Purchase Stream",id:"with-purchase-stream",level:3},{value:"Complete Purchase Flow",id:"complete-purchase-flow",level:3},{value:"Android-Specific Handling",id:"android-specific-handling",level:2},{value:"Pending Transactions",id:"pending-transactions",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Transaction States",id:"transaction-states",level:2},{value:"Related Methods",id:"related-methods",level:2},{value:"Migration from v6.x",id:"migration-from-v6x",level:2},{value:"Important Notes",id:"important-notes",level:2}];function h(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"finishtransaction",children:"finishTransaction()"})}),"\n",(0,s.jsx)(t.A,{}),"\n",(0,s.jsx)(e.p,{children:"Completes a transaction and removes it from the queue."}),"\n",(0,s.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(e.p,{children:["The ",(0,s.jsx)(e.code,{children:"finishTransaction()"})," method marks a transaction as complete, removing it from the pending transactions queue. This is crucial for proper transaction management on both iOS and Android platforms."]}),"\n",(0,s.jsx)(e.h2,{id:"signature",children:"Signature"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"Future<void> finishTransaction({\n  required Purchase purchase,\n  bool? isConsumable,\n})\n"})}),"\n",(0,s.jsx)(e.h2,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Parameter"}),(0,s.jsx)(e.th,{children:"Type"}),(0,s.jsx)(e.th,{children:"Required"}),(0,s.jsx)(e.th,{children:"Description"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"purchase"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"Purchase"})}),(0,s.jsx)(e.td,{children:"\u2705"}),(0,s.jsx)(e.td,{children:"The purchase object to finish"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"isConsumable"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"bool?"})}),(0,s.jsx)(e.td,{children:"\u274c"}),(0,s.jsx)(e.td,{children:"Whether the product is consumable (affects Android behavior)"})]})]})]}),"\n",(0,s.jsx)(e.h2,{id:"platform-behavior",children:"Platform Behavior"}),"\n",(0,s.jsx)(e.h3,{id:"ios",children:"iOS"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Removes the transaction from StoreKit's payment queue"}),"\n",(0,s.jsx)(e.li,{children:"Required for all purchases (consumable and non-consumable)"}),"\n",(0,s.jsx)(e.li,{children:"Must be called after content delivery"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"android",children:"Android"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"For consumables: Consumes the purchase, allowing repurchase"}),"\n",(0,s.jsx)(e.li,{children:"For non-consumables: Acknowledges the purchase"}),"\n",(0,s.jsx)(e.li,{children:"Must acknowledge within 3 days or purchase is refunded"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,s.jsx)(e.h3,{id:"basic-transaction-completion",children:"Basic Transaction Completion"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"// Listen for purchases and finish them\nFlutterInappPurchase.instance.purchaseUpdatedListener.listen((Purchase purchase) async {\n  // Verify and deliver content\n  await _verifyAndDeliver(purchase);\n\n  // Finish the transaction\n  await FlutterInappPurchase.instance.finishTransaction(\n    purchase: purchase,\n    isConsumable: _isConsumable(purchase.productId),\n  );\n});\n"})}),"\n",(0,s.jsx)(e.h3,{id:"with-purchase-stream",children:"With Purchase Stream"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"// Using the purchase stream\nFlutterInappPurchase.instance.purchaseUpdatedListener.listen((Purchase purchase) async {\n  // Process the purchase\n  await _processPurchase(purchase);\n\n  // Finish the transaction\n  await FlutterInappPurchase.instance.finishTransaction(\n    purchase: purchase,\n    isConsumable: true,\n  );\n});\n"})}),"\n",(0,s.jsx)(e.h3,{id:"complete-purchase-flow",children:"Complete Purchase Flow"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"class PurchaseHandler {\n  final _iap = FlutterInappPurchase.instance;\n  final _consumableIds = ['coins_100', 'coins_500', 'powerup_pack'];\n\n  void initialize() {\n    FlutterInappPurchase.instance.purchaseUpdatedListener.listen(_handlePurchase);\n  }\n\n  Future<void> _handlePurchase(Purchase? purchase) async {\n    if (purchase == null) return;\n\n    try {\n      // Step 1: Verify the purchase\n      final isValid = await _verifyPurchase(purchase);\n      if (!isValid) {\n        print('Invalid purchase detected');\n        return;\n      }\n\n      // Step 2: Deliver the content\n      await _deliverContent(purchase.productId!);\n\n      // Step 3: Finish the transaction\n      final isConsumable = _consumableIds.contains(purchase.productId);\n      await _iap.finishTransaction(\n        purchase: purchase,\n        isConsumable: isConsumable,\n      );\n\n      print('Transaction completed successfully');\n\n    } catch (e) {\n      print('Error processing purchase: $e');\n      // Don't finish transaction if processing failed\n      // This keeps it in the queue for retry\n    }\n  }\n\n  Future<bool> _verifyPurchase(Purchase item) async {\n    // Implement your verification logic\n    // - Verify receipt with your backend\n    // - Check transaction ID uniqueness\n    // - Validate product ID\n    return true;\n  }\n\n  Future<void> _deliverContent(String productId) async {\n    // Deliver the purchased content\n    switch (productId) {\n      case 'coins_100':\n        await _addCoins(100);\n        break;\n      case 'coins_500':\n        await _addCoins(500);\n        break;\n      case 'premium':\n        await _unlockPremium();\n        break;\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"android-specific-handling",children:"Android-Specific Handling"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"Future<void> handleAndroidPurchase(Purchase item) async {\n  if (!Platform.isAndroid) return;\n\n  // Check acknowledgment status\n  if (item.isAcknowledgedAndroid == false) {\n    if (_isConsumable(item.productId)) {\n      // Consume the purchase\n      await _iap.consumePurchaseAndroid(item.purchaseToken!);\n    } else {\n      // Acknowledge non-consumable\n      await _iap.acknowledgePurchaseAndroid(\n        purchaseToken: item.purchaseToken!,\n      );\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"pending-transactions",children:"Pending Transactions"}),"\n",(0,s.jsx)(e.p,{children:"Handle pending transactions on app startup:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"class TransactionManager {\n  Future<void> processPendingTransactions() async {\n    try {\n      // Get pending transactions\n      final pending = await FlutterInappPurchase.instance.getPendingTransactionsIOS();\n\n      if (pending != null && pending.isNotEmpty) {\n        print('Found ${pending.length} pending transactions');\n\n        for (var transaction in pending) {\n          // Process each pending transaction\n          await _processPendingTransaction(transaction);\n        }\n      }\n    } catch (e) {\n      print('Error processing pending transactions: $e');\n    }\n  }\n\n  Future<void> _processPendingTransaction(Purchase item) async {\n    // Verify the transaction\n    final isValid = await _verifyTransaction(item);\n\n    if (isValid) {\n      // Deliver content if not already delivered\n      if (!await _isContentDelivered(item.transactionId)) {\n        await _deliverContent(item.productId!);\n      }\n\n      // Finish the transaction\n      await FlutterInappPurchase.instance.finishTransaction(\n        purchase: item,\n      );\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Always Verify First"}),": Verify purchases before finishing transactions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Handle Failures"}),": Keep transactions pending if verification fails"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Idempotent Delivery"}),": Ensure content delivery is idempotent"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Process on Startup"}),": Check for pending transactions when app launches"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Track Delivery"}),": Maintain records of delivered content"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"Future<void> safeFinishTransaction(Purchase item) async {\n  const maxRetries = 3;\n  var retryCount = 0;\n\n  while (retryCount < maxRetries) {\n    try {\n      await _iap.finishTransaction(\n        purchase: item,\n        isConsumable: _isConsumable(item.productId),\n      );\n      print('Transaction finished successfully');\n      break;\n\n    } catch (e) {\n      retryCount++;\n      print('Failed to finish transaction (attempt $retryCount): $e');\n\n      if (retryCount >= maxRetries) {\n        // Log error but don't throw\n        // Transaction will remain pending\n        _logError('Failed to finish transaction after $maxRetries attempts', item);\n      } else {\n        // Wait before retry\n        await Future.delayed(Duration(seconds: retryCount));\n      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"transaction-states",children:"Transaction States"}),"\n",(0,s.jsx)(e.p,{children:"Monitor transaction states for proper handling:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"void handleTransactionState(Purchase item) {\n  if (Platform.isIOS) {\n    switch (item.transactionStateIOS) {\n      case TransactionState.purchased:\n      case TransactionState.restored:\n        // Safe to finish\n        _finishTransaction(item);\n        break;\n      case TransactionState.failed:\n        // Don't finish failed transactions\n        print('Transaction failed');\n        break;\n      case TransactionState.purchasing:\n      case TransactionState.deferred:\n        // Wait for final state\n        print('Transaction pending');\n        break;\n    }\n  } else if (Platform.isAndroid) {\n    switch (item.purchaseStateAndroid) {\n      case PurchaseState.purchased:\n        // Safe to finish\n        _finishTransaction(item);\n        break;\n      case PurchaseState.pending:\n        // Don't finish pending transactions\n        print('Purchase pending');\n        break;\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"related-methods",children:"Related Methods"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"/flutter_inapp_purchase/8.1/api/methods/request-purchase",children:(0,s.jsx)(e.code,{children:"requestPurchase()"})})," - Initiates a purchase"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"/flutter_inapp_purchase/8.1/api/methods/get-available-purchases",children:(0,s.jsx)(e.code,{children:"getAvailablePurchases()"})})," - Gets unfinished purchases"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"acknowledgePurchaseAndroid()"})," - Android-specific acknowledgment (see example above)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"consumePurchaseAndroid()"})," - Android-specific consumption (see example above)"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"migration-from-v6x",children:"Migration from v6.x"}),"\n",(0,s.jsxs)(e.p,{children:["Version 7.0 significantly simplifies the ",(0,s.jsx)(e.code,{children:"finishTransaction"})," API:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"// Before (v6.x) - 10 individual parameters\nawait iap.finishTransaction(\n  id: purchase.id,\n  isAutoRenewing: purchase.isAutoRenewing,\n  platform: purchase.platform,\n  productId: purchase.productId,\n  purchaseState: purchase.purchaseState,\n  purchaseToken: purchase.purchaseToken,\n  quantity: purchase.quantity,\n  transactionDate: purchase.transactionDate,\n  isConsumable: true,\n);\n\n// After (v7.0) - Just pass the Purchase object\nawait iap.finishTransaction(\n  purchase: purchase,\n  isConsumable: true,\n);\n"})}),"\n",(0,s.jsxs)(e.p,{children:["This reduces boilerplate by ",(0,s.jsx)(e.strong,{children:"80%"})," while maintaining all functionality. The method now handles serialization internally."]}),"\n",(0,s.jsx)(e.h2,{id:"important-notes",children:"Important Notes"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"iOS Requirements"}),": All transactions must be finished, even failed ones"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Android 3-Day Rule"}),": Acknowledge purchases within 3 days or they're refunded"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Consumables"}),": Must be consumed on Android to allow repurchase"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Network Failures"}),": Transactions remain pending if finish fails"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"App Termination"}),": Unfinished transactions persist across app sessions"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(h,{...n})}):h(n)}}}]);