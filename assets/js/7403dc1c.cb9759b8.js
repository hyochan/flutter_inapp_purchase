"use strict";(self.webpackChunkflutter_inapp_purchase_docs=self.webpackChunkflutter_inapp_purchase_docs||[]).push([[7482],{6730:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"guides/subscription-validation","title":"Subscription Validation","description":"flutterinapppurchase exposes modern StoreKit 2 (iOS) and Google Play Billing (Android) pipelines. This guide walks through the data available on the Dart side, how it maps to the underlying native APIs, and practical strategies to answer common lifecycle questions such as \\"is the user currently inside their free trial?\\"","source":"@site/docs/guides/subscription-validation.md","sourceDirName":"guides","slug":"/guides/subscription-validation","permalink":"/flutter_inapp_purchase/docs/guides/subscription-validation","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/flutter_inapp_purchase/tree/main/docs/docs/guides/subscription-validation.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Subscription Validation"},"sidebar":"docsSidebar","previous":{"title":"Subscription Offers","permalink":"/flutter_inapp_purchase/docs/guides/subscription-offers"},"next":{"title":"Offer Code Redemption","permalink":"/flutter_inapp_purchase/docs/guides/offer-code-redemption"}}');var t=n(4848),r=n(8453);const a={sidebar_position:4,title:"Subscription Validation"},c="Subscription Validation",o={},d=[{value:"Summary of Key APIs",id:"summary-of-key-apis",level:2},{value:"Working with getAvailablePurchases",id:"working-with-getavailablepurchases",level:2},{value:"Data Included",id:"data-included",level:3},{value:"Limitations",id:"limitations",level:3},{value:"Using getActiveSubscriptions",id:"using-getactivesubscriptions",level:2},{value:"Fields Available",id:"fields-available",level:3},{value:"Deriving Subscription Phase",id:"deriving-subscription-phase",level:2},{value:"StoreKit 2 Status API (iOS)",id:"storekit-2-status-api-ios",level:2},{value:"Phase Reference",id:"phase-reference",level:3},{value:"Server-Side Validation",id:"server-side-validation",level:2},{value:"iOS - App Store Server API",id:"ios---app-store-server-api",level:3},{value:"Android - Google Play Developer API",id:"android---google-play-developer-api",level:3},{value:"Client-Side Validation (iOS)",id:"client-side-validation-ios",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Complete Flow Example",id:"complete-flow-example",level:2},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"subscription-validation",children:"Subscription Validation"})}),"\n",(0,t.jsx)(i.p,{children:'flutter_inapp_purchase exposes modern StoreKit 2 (iOS) and Google Play Billing (Android) pipelines. This guide walks through the data available on the Dart side, how it maps to the underlying native APIs, and practical strategies to answer common lifecycle questions such as "is the user currently inside their free trial?"'}),"\n",(0,t.jsxs)(i.p,{children:["iOS and Android share the same high-level API surface, but individual capabilities differ. Notes in each section call out platform-specific behaviour\u2014for example, ",(0,t.jsx)(i.code,{children:"subscriptionStatusIOS"})," only exists on Apple platforms, whereas Android relies on Purchase objects and the Play Developer API."]}),"\n",(0,t.jsx)(i.h2,{id:"summary-of-key-apis",children:"Summary of Key APIs"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Capability"}),(0,t.jsx)(i.th,{children:"API"}),(0,t.jsx)(i.th,{children:"iOS"}),(0,t.jsx)(i.th,{children:"Android"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Fetch latest entitlement records the store still considers active"}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"getAvailablePurchases"})}),(0,t.jsx)(i.td,{children:"Wraps StoreKit 2 Transaction.currentEntitlements; optional flags control listener mirror & active-only filtering"}),(0,t.jsx)(i.td,{children:"Queries Play Billing twice (inapp + subs) and merges validated purchases, exposing purchaseToken for server use"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Filter entitlements down to subscriptions only"}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"getActiveSubscriptions"})}),(0,t.jsx)(i.td,{children:"Adds expirationDateIOS, daysUntilExpirationIOS, environmentIOS convenience fields"}),(0,t.jsx)(i.td,{children:"Re-shapes merged purchase list and surfaces autoRenewingAndroid, purchaseToken, and willExpireSoon placeholders"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Inspect fine-grained subscription phase"}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"subscriptionStatusIOS"})}),(0,t.jsx)(i.td,{children:"StoreKit 2 status API (inTrialPeriod, inGracePeriod, etc.)"}),(0,t.jsx)(i.td,{children:"Not available; pair getAvailablePurchases with Play Developer API for phase data"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Retrieve receipts for validation"}),(0,t.jsxs)(i.td,{children:[(0,t.jsx)(i.code,{children:"getReceiptDataIOS"}),", ",(0,t.jsx)(i.code,{children:"validateReceiptIOS"})]}),(0,t.jsx)(i.td,{children:"Provides App Store receipt / JWS for backend validation"}),(0,t.jsx)(i.td,{children:"validateReceipt forwards to OpenIAP's Google Play validator and expects purchaseToken / packageName"})]})]})]}),"\n",(0,t.jsx)(i.h2,{id:"working-with-getavailablepurchases",children:"Working with getAvailablePurchases"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"getAvailablePurchases"})," returns every purchase that the native store still considers active for the signed-in user."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"iOS"})," \u2014 The library bridges directly to StoreKit 2's Transaction.currentEntitlements, so each item is a fully validated ",(0,t.jsx)(i.code,{children:"PurchaseIOS"}),". Optional flags (",(0,t.jsx)(i.code,{children:"onlyIncludeActiveItemsIOS"}),", ",(0,t.jsx)(i.code,{children:"alsoPublishToEventListenerIOS"}),") are forwarded to StoreKit and mimic the native behaviour."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Android"})," \u2014 Google Play Billing keeps one list for in-app products and another for subscriptions. The wrapper automatically queries both (",(0,t.jsx)(i.code,{children:"type: 'inapp'"})," and ",(0,t.jsx)(i.code,{children:"type: 'subs'"}),"), merges the results, and validates them before returning control to Dart."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"class SubscriptionGate extends StatefulWidget {\n  final List<String> subscriptionIds;\n\n  const SubscriptionGate({required this.subscriptionIds, Key? key}) : super(key: key);\n\n  @override\n  State<SubscriptionGate> createState() => _SubscriptionGateState();\n}\n\nclass _SubscriptionGateState extends State<SubscriptionGate> {\n  final _iap = FlutterInappPurchase.instance;\n  Map<String, ActiveSubscription> _activeSubscriptionInfo = {};\n  bool _hasActiveSubscription = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _checkActiveSubscriptions();\n  }\n\n  Future<void> _checkActiveSubscriptions() async {\n    try {\n      // Get active subscription summaries\n      final summaries = await _iap.getActiveSubscriptions(widget.subscriptionIds);\n\n      // Get corresponding Purchase objects for additional details\n      final purchases = await _iap.getAvailablePurchases(\n        onlyIncludeActiveItemsIOS: true,\n      );\n\n      // Create map of summaries by product ID\n      final summaryByProduct = <String, ActiveSubscription>{};\n      for (final summary in summaries) {\n        summaryByProduct[summary.productId] = summary;\n      }\n\n      // Match purchases with summaries\n      final activeSubs = <Purchase>[];\n      final addedProducts = <String>{};\n\n      for (final purchase in purchases) {\n        if (summaryByProduct.containsKey(purchase.productId) &&\n            addedProducts.add(purchase.productId)) {\n          activeSubs.add(purchase);\n        }\n      }\n\n      if (!mounted) return;\n\n      setState(() {\n        _activeSubscriptionInfo = summaryByProduct;\n        _hasActiveSubscription = activeSubs.isNotEmpty;\n      });\n    } catch (e) {\n      debugPrint('Error checking subscriptions: $e');\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Render locked/unlocked UI based on subscription status\n    return _hasActiveSubscription ? UnlockedContent() : LockedContent();\n  }\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"data-included",children:"Data Included"}),"\n",(0,t.jsx)(i.p,{children:"For each purchase you can inspect fields such as:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"transactionDate"}),": Transaction timestamp"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"transactionId"}),": Unique transaction identifier"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"productId"}),": Product SKU"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"purchaseToken"}),": Token for server-side validation"]}),"\n",(0,t.jsx)(i.li,{children:"Platform-specific fields (see Purchase types)"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsx)(i.p,{children:'StoreKit does not bake "current phase" indicators into these records. To answer questions like "is the user still in a free trial?" you need either the StoreKit status API or server-side receipt validation.'}),"\n",(0,t.jsx)(i.h2,{id:"using-getactivesubscriptions",children:"Using getActiveSubscriptions"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"getActiveSubscriptions"})," is a helper that filters down to subscription products and adds convenience fields. It returns an array of ",(0,t.jsx)(i.code,{children:"ActiveSubscription"})," objects:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"final activeSubscriptions = await iap.getActiveSubscriptions([\n  'yearly_subscription',\n  'monthly_subscription',\n]);\n\nif (activeSubscriptions.isEmpty) {\n  // User has no valid subscription\n  print('No active subscriptions');\n} else {\n  for (final sub in activeSubscriptions) {\n    print('Product: ${sub.productId}');\n    print('Transaction ID: ${sub.transactionId}');\n    print('Expiration (iOS): ${sub.expirationDateIOS}');\n    print('Auto-renewing (Android): ${sub.autoRenewingAndroid}');\n    print('Environment (iOS): ${sub.environmentIOS}');\n  }\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"fields-available",children:"Fields Available"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"isActive"}),": Always true as long as the subscription remains in the current entitlement set"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"expirationDateIOS"})," & ",(0,t.jsx)(i.code,{children:"daysUntilExpirationIOS"}),": Surfaced directly from StoreKit"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"transactionId"})," / ",(0,t.jsx)(i.code,{children:"purchaseToken"}),": Handy for reconciling with receipts or Play Billing"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"willExpireSoon"}),": Flag set when the subscription is within its grace window"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"autoRenewingAndroid"}),": Reflects the Google Play auto-renew status"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"environmentIOS"}),": Sandbox or Production"]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Platform note"}),": On iOS the helper re-shapes StoreKit 2 entitlement objects. On Android it operates on the merged inapp + subs purchase list, so the output contains both one-time products and subscriptions unless you filter by specific product IDs."]}),"\n",(0,t.jsx)(i.h2,{id:"deriving-subscription-phase",children:"Deriving Subscription Phase"}),"\n",(0,t.jsx)(i.p,{children:"If you want a coarse subscription phase that works on both platforms, compute it from the data:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"enum SubscriptionPhase { subscribed, expiringSoon, expired }\n\nconst msInDay = 1000 * 60 * 60 * 24;\nconst graceWindowDays = 3;\n\nFuture<SubscriptionPhase> getCurrentPhase(String sku) async {\n  final subscriptions = await iap.getActiveSubscriptions([sku]);\n  final entry = subscriptions.where((sub) => sub.productId == sku).firstOrNull;\n\n  if (entry == null) {\n    return SubscriptionPhase.expired;\n  }\n\n  final now = DateTime.now().millisecondsSinceEpoch;\n  final expiresAt = entry.expirationDateIOS;\n\n  if (entry.daysUntilExpirationIOS != null && entry.daysUntilExpirationIOS! <= 0) {\n    return SubscriptionPhase.expired;\n  }\n\n  if (expiresAt != null && expiresAt <= now) {\n    return SubscriptionPhase.expired;\n  }\n\n  final graceWindowMs = graceWindowDays * msInDay;\n  if ((expiresAt != null && expiresAt - now <= graceWindowMs) ||\n      (entry.daysUntilExpirationIOS != null &&\n          entry.daysUntilExpirationIOS! * msInDay <= graceWindowMs) ||\n      entry.autoRenewingAndroid == false) {\n    return SubscriptionPhase.expiringSoon;\n  }\n\n  return SubscriptionPhase.subscribed;\n}\n"})}),"\n",(0,t.jsx)(i.h2,{id:"storekit-2-status-api-ios",children:"StoreKit 2 Status API (iOS)"}),"\n",(0,t.jsxs)(i.p,{children:["When you need to know the exact lifecycle phase on iOS, call ",(0,t.jsx)(i.code,{children:"subscriptionStatusIOS"}),". This maps to StoreKit 2's ",(0,t.jsx)(i.code,{children:"Product.SubscriptionInfo.Status"})," API and returns an array of status entries for the subscription group."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"final statuses = await iap.subscriptionStatusIOS('yearly_subscription');\nfinal latestState = statuses.isNotEmpty ? statuses.first.state : 'unknown';\n\nswitch (latestState) {\n  case 'subscribed':\n    print('Subscription is active');\n    break;\n  case 'inTrialPeriod':\n    print('User is in free trial');\n    break;\n  case 'inGracePeriod':\n    print('Auto-renewal failed, in grace period');\n    break;\n  case 'expired':\n    print('Subscription expired');\n    break;\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"phase-reference",children:"Phase Reference"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"State Value"}),(0,t.jsx)(i.th,{children:"Meaning"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"subscribed"})}),(0,t.jsx)(i.td,{children:"Subscription is active and billing is up to date"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"expired"})}),(0,t.jsx)(i.td,{children:"Subscription is no longer active"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"inGracePeriod"})}),(0,t.jsx)(i.td,{children:"Auto-renewal failed but StoreKit granted a grace period"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"inBillingRetryPeriod"})}),(0,t.jsx)(i.td,{children:"Auto-renewal failed and StoreKit is retrying payment"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"revoked"})}),(0,t.jsx)(i.td,{children:"Apple revoked the subscription (e.g., refunds)"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"inIntroOfferPeriod"})}),(0,t.jsx)(i.td,{children:"User is in a paid introductory offer"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"inTrialPeriod"})}),(0,t.jsx)(i.td,{children:"User is currently in the free-trial window"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"paused"})}),(0,t.jsx)(i.td,{children:"Subscription manually paused by the user"})]})]})]}),"\n",(0,t.jsx)(i.h2,{id:"server-side-validation",children:"Server-Side Validation"}),"\n",(0,t.jsx)(i.h3,{id:"ios---app-store-server-api",children:"iOS - App Store Server API"}),"\n",(0,t.jsx)(i.p,{children:"Validate receipts on your backend:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"// Get receipt data\nfinal receiptData = await iap.getReceiptDataIOS();\n\n// Send to your backend for validation\nfinal response = await http.post(\n  Uri.parse('https://your-backend.com/validate-ios'),\n  body: {'receipt_data': receiptData},\n);\n"})}),"\n",(0,t.jsx)(i.p,{children:"Backend validation (App Store verifyReceipt endpoint):"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-javascript",children:"const response = await fetch(\n  'https://buy.itunes.apple.com/verifyReceipt',\n  {\n    method: 'POST',\n    body: JSON.stringify({\n      'receipt-data': receiptData,\n      'password': SHARED_SECRET,\n    }),\n  }\n);\n\nconst data = await response.json();\n// Check data.status === 0 for valid receipt\n// Inspect data.latest_receipt_info for is_trial_period, etc.\n"})}),"\n",(0,t.jsx)(i.h3,{id:"android---google-play-developer-api",children:"Android - Google Play Developer API"}),"\n",(0,t.jsx)(i.p,{children:"Validate purchase tokens on your backend using Google Play Developer API to get detailed subscription phase data."}),"\n",(0,t.jsx)(i.h2,{id:"client-side-validation-ios",children:"Client-Side Validation (iOS)"}),"\n",(0,t.jsx)(i.p,{children:"For quick client-side validation on iOS:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"final result = await iap.validateReceiptIOS(\n  sku: 'yearly_subscription',\n);\n\nif (result.isValid) {\n  print('Receipt is valid');\n  print('JWS Representation: ${result.jwsRepresentation}');\n} else {\n  print('Receipt validation failed');\n}\n"})}),"\n",(0,t.jsx)(i.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:["Use ",(0,t.jsx)(i.code,{children:"subscriptionStatusIOS"})," for fast, on-device checks"]})," when UI needs to react immediately (iOS only)"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Periodically upload receipts to your backend"})," for authoritative validation and entitlement provisioning"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Recalculate client caches"})," (",(0,t.jsx)(i.code,{children:"getAvailablePurchases"}),") after server reconciliation"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Combine both approaches"}),": Use client APIs for immediate feedback, server validation for security"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Handle both platforms"}),": Use ",(0,t.jsx)(i.code,{children:"getActiveSubscriptions"})," for cross-platform checks, enhance with ",(0,t.jsx)(i.code,{children:"subscriptionStatusIOS"})," on iOS"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"complete-flow-example",children:"Complete Flow Example"}),"\n",(0,t.jsx)(i.p,{children:"A typical subscription screen might:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["Call ",(0,t.jsx)(i.code,{children:"initConnection"})," and ",(0,t.jsx)(i.code,{children:"fetchProducts"})," when mounted"]}),"\n",(0,t.jsx)(i.li,{children:"Set up purchase listeners to observe updates"}),"\n",(0,t.jsxs)(i.li,{children:["Fetch ",(0,t.jsx)(i.code,{children:"getAvailablePurchases"})," on launch to restore entitlements"]}),"\n",(0,t.jsxs)(i.li,{children:["Query ",(0,t.jsx)(i.code,{children:"subscriptionStatusIOS"})," (iOS) to display trial/grace period status"]}),"\n",(0,t.jsx)(i.li,{children:"Sync receipts to your server to unlock cross-device access"}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"class SubscriptionManager {\n  final _iap = FlutterInappPurchase.instance;\n\n  Future<void> initialize() async {\n    await _iap.initConnection();\n\n    // Restore purchases\n    final purchases = await _iap.getAvailablePurchases();\n\n    // Check subscription status (iOS)\n    if (Platform.isIOS) {\n      final statuses = await _iap.subscriptionStatusIOS('yearly_sub');\n      final inTrial = statuses.any((s) => s.state == 'inTrialPeriod');\n      print('In trial: $inTrial');\n    }\n\n    // Validate on server\n    if (Platform.isIOS) {\n      final receiptData = await _iap.getReceiptDataIOS();\n      await validateOnServer(receiptData);\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(i.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"./subscription-offers",children:"Subscription Offers"})," - Handle subscription purchases"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"./error-handling",children:"Error Handling"})," - Handle validation errors"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"./troubleshooting",children:"Troubleshooting"})," - Debug validation issues"]}),"\n"]})]})}function p(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>c});var s=n(6540);const t={},r=s.createContext(t);function a(e){const i=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:i},e.children)}}}]);